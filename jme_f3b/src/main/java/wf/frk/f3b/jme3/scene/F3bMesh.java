// Generated by delombok at Sat Jul 28 16:45:23 CEST 2018
package wf.frk.f3b.jme3.scene;

import java.nio.FloatBuffer;
import java.nio.ShortBuffer;
import java.util.ArrayList;
import java.util.List;

import com.jme3.material.Material;
import com.jme3.math.FastMath;
import com.jme3.scene.Mesh;
import com.jme3.scene.VertexBuffer;
import com.jme3.scene.VertexBuffer.Format;
import com.jme3.scene.VertexBuffer.Type;
import com.jme3.scene.VertexBuffer.Usage;
import com.jme3.util.BufferUtils;
import f3b.Meshes.IndexArray;
import f3b.Meshes.Skin;
import f3b.Meshes.VertexArray;

public class F3bMesh {
	@java.lang.SuppressWarnings("all")
	private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(F3bMesh.class);
	public final f3b.Meshes.Mesh src;
	public final Material material;

	public String getName() {
		return src.getName();
	}

	public Mesh toJME() throws IllegalArgumentException {
		if (src.getIndexArraysCount() > 1) throw new IllegalArgumentException("doesn\'t support more than 1 index array");
		// if (src.getLod() > 1) throw new IllegalArgumentException("doesn\'t support lod > 1 : " + src.getLod());
		Mesh dst = new Mesh();
		//		context.put("G~meshName~"+dst.hashCode(),src.getName());
		dst.setMode(wf.frk.f3b.jme3.ext.f3b.TypesExt.toJME(src.getPrimitive()));
		for (VertexArray va : src.getVertexArraysList()) {
			try {
				Type type = wf.frk.f3b.jme3.ext.f3b.TypesExt.toJME(va.getAttrib());
				VertexBuffer vb = new VertexBuffer(type);
				vb.setupData(Usage.Static, va.getFloats().getStep(), Format.Float, BufferUtils.createFloatBuffer(wf.frk.f3b.jme3.ext.f3b.FloatBufferExt.array(va.getFloats())));
				dst.setBuffer(vb);
				//dst.setBuffer(type,va.getFloats().getStep(),va.getFloats().array());
				log.debug("add {}", dst.getBuffer(type));
			} catch (IllegalArgumentException ex) {
				log.warn("{} not supported. Skip.", va.getAttrib());
			}
		}
		for (IndexArray va : src.getIndexArraysList()) {
			VertexBuffer vb = new VertexBuffer(VertexBuffer.Type.Index);
			vb.setupData(Usage.Static, va.getInts().getStep(), Format.UnsignedInt, BufferUtils.createIntBuffer(wf.frk.f3b.jme3.ext.f3b.UintBufferExt.array(va.getInts())));
			dst.setBuffer(vb);
//			dst.setBuffer(VertexBuffer.Type.Index,va.getInts().getStep(),va.getInts().array());
		}
		if (src.hasSkin()) applySkin(src.getSkin(), dst);
		dst.updateCounts();
		dst.updateBound();
		return dst;
	}

	public int getLodLevel(){
		return src.getLod();
	}

	public String getId(){
		return src.getId();
	}


	private static class BoneXWeight{
		int index;
		float weight;
		BoneXWeight(int index,float weight){this.index=index;this.weight=weight;}
	}
	protected Mesh applySkin(Skin skin, Mesh dst) {
		List<Integer> nbonesl=skin.getBoneCountList();
		List<Float> weightsl=skin.getBoneWeightList();
		List<Integer> indicesl=skin.getBoneIndexList();
		dst.setBuffer(VertexBuffer.Type.BoneIndex, 4, BufferUtils.createShortBuffer(nbonesl.size()*4));
		dst.setBuffer(VertexBuffer.Type.BoneWeight, 4, BufferUtils.createFloatBuffer(nbonesl.size()*4));
        dst.getBuffer(VertexBuffer.Type.BoneIndex).setUsage(VertexBuffer.Usage.CpuOnly);
		dst.getBuffer(VertexBuffer.Type.BoneWeight).setUsage(VertexBuffer.Usage.CpuOnly);
		
		VertexBuffer weightsHW = new VertexBuffer(Type.HWBoneWeight);
		VertexBuffer indicesHW = new VertexBuffer(Type.HWBoneIndex);
		indicesHW.setUsage(VertexBuffer.Usage.CpuOnly);
		weightsHW.setUsage(VertexBuffer.Usage.CpuOnly);
		dst.setBuffer(weightsHW);
		dst.setBuffer(indicesHW);
		dst.setMaxNumWeights(4);

		int k=0;
		for(int i=0;i<nbonesl.size();i++){
			int nbones=nbonesl.get(i);			
			ArrayList<BoneXWeight>  ww=new ArrayList<BoneXWeight>();
			for(int j=0;j<nbones;j++){
				ww.add(new BoneXWeight(indicesl.get(k),weightsl.get(k)));
				k++;
			}
			while(ww.size()<4)ww.add(new BoneXWeight(0,0));
			ww.sort((a,b)->a.weight>b.weight?-1:(a.weight==b.weight?0:1));
			if(ww.size()>4)log.warn("More than 4 weights for bone. Trim");
			List<BoneXWeight> ww2=ww.subList(0,4);

			assert ww2.get(0).weight>=ww2.get(1).weight&&ww2.get(1).weight>=ww2.get(2).weight&&ww2.get(2).weight>=ww2.get(3).weight : "Wrong order!"; 
			normalizeWeights(ww2);
			assert ww2.size()==4 : "Wrong number of weight. Expected 4. Got "+ww2.size();


			for(BoneXWeight bxw:ww2){
				ShortBuffer ib=(ShortBuffer)dst.getBuffer(VertexBuffer.Type.BoneIndex).getData();
				FloatBuffer wb=(FloatBuffer)dst.getBuffer(VertexBuffer.Type.BoneWeight).getData();
				ib.put((short)bxw.index);
				wb.put(bxw.weight);
			}

			
		}
		dst.generateBindPose();
		return dst;
	}

	private void normalizeWeights(List<BoneXWeight> ww2) {
		float a=ww2.get(0).weight;
		float b=ww2.get(1).weight;
		float c=ww2.get(2).weight;
		float d=ww2.get(3).weight;
		float sum=a+b+c+d;
		float i=sum==0?0:1f/sum;
		a*=i;
		b*=i;
		c*=i;
		d*=i;
		ww2.get(0).weight=a;
		ww2.get(1).weight=b;
		ww2.get(2).weight=c;
		ww2.get(3).weight=d;
	}

	@java.lang.SuppressWarnings("all")
	public F3bMesh(final f3b.Meshes.Mesh src, final Material material) {
		this.src = src;
		this.material = material;
	}
}
