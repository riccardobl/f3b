// Generated by delombok at Sat Jul 28 16:45:23 CEST 2018
package wf.frk.f3b.jme3.mergers.relations.linkers;

import static wf.frk.f3b.jme3.mergers.relations.LinkerHelpers.getRef1;
import static wf.frk.f3b.jme3.mergers.relations.LinkerHelpers.getRef2;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import com.jme3.export.Savable;
import wf.frk.f3b.jme3.physicsloader.ConstraintData;
import wf.frk.f3b.jme3.physicsloader.PhysicsLoader;
import wf.frk.f3b.jme3.physicsloader.constraint.GenericConstraint;
import wf.frk.f3b.jme3.physicsloader.rigidbody.RigidBody;
import com.jme3.scene.Node;
import com.jme3.scene.Spatial;
import com.jme3.scene.control.Control;
import f3b.Physics.Constraint;
import f3b.Physics.ConstraintGeneric;
import wf.frk.f3b.jme3.F3bContext;
import wf.frk.f3b.jme3.mergers.RelationsMerger;
import wf.frk.f3b.jme3.mergers.relations.Linker;
import wf.frk.f3b.jme3.mergers.relations.RefData;
import wf.frk.f3b.jme3.runtime.F3bPhysicsRuntimeLoader;

public class PhysicsToSpatial implements Linker {
	@java.lang.SuppressWarnings("all")
	private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(PhysicsToSpatial.class);
	protected long LAST_CLONE_ID = 0;

	@Override
	public boolean doLink(RelationsMerger rloader, RefData data) {
		if (loadRB(rloader, data)) return true;
		return false;
	}

	protected boolean loadRB(RelationsMerger rloader, RefData data) {
		RigidBody op1 = getRef1(data, RigidBody.class);
		Spatial op2 = getRef2(data, Spatial.class);
		if (op1 == null || op2 == null) return false; 
		PhysicsLoader<Savable, Savable> loader = (PhysicsLoader<Savable,Savable>)data.context.getSettings().getPhysicsLoader();
		if (loader != null) {
			Savable pc = loader.load(data.context.getSettings(), op2, op1);
			log.debug("Load rigidbody {}", data.ref1);
			if(pc!=null&&pc instanceof Control){
				loader.attachToSpatial(pc,op2);
				String linkRef = "G~slink4phy~" + (LAST_CLONE_ID++) + "~" + data.ref1;
				data.context.put(linkRef, op2, data.ref1);
				applyCTs(op2, data.ref1, data.context, data.root);
			}
		}
		return true;
	}

	protected void applyCTs(Spatial phy1S, String phy1Ref, F3bContext ctx, Node root) {
		Collection<Constraint> constraints = ctx.get("G~constraints");
		if (constraints != null) {
			for (byte i = 0; i < 2; i++) {
//				for(Constraint c:constraints){
				for (Iterator<Constraint> c_i = constraints.iterator(); c_i.hasNext(); ) {
					Constraint c = c_i.next();
					if (!(i == 0 ? c.getARef() : c.getBRef()).equals(phy1Ref)) continue;
					String phy2Ref = i == 1 ? c.getARef() : c.getBRef();
					if (ctx.get(phy2Ref) == null) {
						log.debug("Found constraint element {}, second element is missing... skip...", phy1Ref);
						continue;
					}
					log.debug("Found constraint elements {} - {}", phy1Ref, phy2Ref);
					List<String> linked = ctx.linkedRefs(phy2Ref);
					for (String l : linked) {
						if (l.startsWith("G~slink4phy~")) {
							Spatial phy2S = ctx.get(l);
							Spatial a;
							Spatial b;
							if (i == 1) {
								// Reorder
								a = phy2S;
								b = phy1S;
							} else {
								a = phy1S;
								b = phy2S;
							}
							applyCT(c, a, b, ctx, root);
							// Remove consumed constraint (Good idea??)
							c_i.remove();
							break;
						}
					}
				}
			}
		} else {
			log.debug("Constraints map not found.");
		}
	}

	protected void applyCT(Constraint ct, Spatial a, Spatial b, F3bContext ctx, Node root) {
		// Parse constraint
		ConstraintData ct_data = null;
		if (ct.hasGeneric()) {
			ConstraintGeneric f3b_generic_ct = ct.getGeneric();
			GenericConstraint generic_ct = new GenericConstraint();
			generic_ct.pivotA = wf.frk.f3b.jme3.ext.f3b.TypesExt.toJME(f3b_generic_ct.getPivotA());
			generic_ct.pivotB = wf.frk.f3b.jme3.ext.f3b.TypesExt.toJME(f3b_generic_ct.getPivotB());
			generic_ct.pivotA = wf.frk.f3b.jme3.ext.f3b.TypesExt.toJME(f3b_generic_ct.getPivotA());
			generic_ct.upperAngularLimit = wf.frk.f3b.jme3.ext.f3b.TypesExt.toJME(f3b_generic_ct.getUpperAngularLimit());
			generic_ct.lowerAngularLimit = wf.frk.f3b.jme3.ext.f3b.TypesExt.toJME(f3b_generic_ct.getLowerAngularLimit());
			generic_ct.upperLinearLimit = wf.frk.f3b.jme3.ext.f3b.TypesExt.toJME(f3b_generic_ct.getUpperLinearLimit());
			generic_ct.lowerLinearLimit = wf.frk.f3b.jme3.ext.f3b.TypesExt.toJME(f3b_generic_ct.getLowerLinearLimit());
			generic_ct.disableCollisionsBetweenLinkedNodes = f3b_generic_ct.getDisableCollisions();
			ct_data = generic_ct;
		} // else if ... [Only one type.]
		if (ct_data == null) {
			log.warn("Constraint {} not supported", ct);
			return;
		}
		try {
			log.debug("Store constraint {} [{}-{}] in scene", ct_data, a, b);
			Spatial constraint_node = F3bPhysicsRuntimeLoader.storeConstraintInScene(ctx.getSettings(), a, b, ct_data);
			root.attachChild(constraint_node);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
